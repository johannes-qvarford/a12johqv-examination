<Domain name="Towers" classname="TowersDomain" package="towers.mmpm">
  <!-- autor: David Llanso based in previous D2 work -->

  <ActionSet package="towers.mmpm.actions">
    
    <Action name="Accept">
      <PreCondition>true</PreCondition>
      <FailureCondition>false</FailureCondition>
      <SuccessCondition>true</SuccessCondition>
    </Action>
    
    <Action name="Build">
      <Parameter name="type" type="ENTITY_TYPE"/>
      <Parameter name="coor" type="COORDINATE"/>
      <Parameter name="lifeTime" type="INTEGER"/>
      <ValidCondition>
        <![CDATA[
        BuildableCoordinates(coor) && NonBlockingPath(coor)
        ]]>
      </ValidCondition>
      <PreCondition>
        <![CDATA[
        BuildableCoordinates(coor) && NonBlockingPath(coor) &&
        (Gold() >= BuildingCost(type)) 
        ]]>
      </PreCondition>
      <OnFailureCondition>
        lifeTime = 32 + cycle
      </OnFailureCondition>
      <FailureCondition>
        <!--cycle >= lifeTime-->
        Timer(lifeTime)
      </FailureCondition>
      <SuccessCondition>
        EntityTypeAt(type, coor)
      </SuccessCondition>
    </Action>
    
  </ActionSet>

  

  <SensorSet package="towers.mmpm.sensors">
    
    <Sensor name="BuildableCoordinates" type="BOOLEAN">
      <Parameter name="coor" type="COORDINATE"/>
      <Code>
        <![CDATA[
        IsCellEmpty(coor) && 
         	( (DistanceEC(ClosestEntity(coor,Type("towers.mmpm.entities.TTower"), player), coor) <= 80.0) ||
         	  (DistanceEC(ClosestEntity(coor,Type("towers.mmpm.entities.TBase"), player), coor) <= 80.0) )
        ]]>
      </Code>
    </Sensor>

    <Sensor name="NonBlockingPath" type="BOOLEAN">
      <Parameter name="coor" type="COORDINATE"/>
      <Code language="java">
        <![CDATA[

        if (parameters == null) {
            return 1.0f;
        }
        boolean blocked[];
        gatech.mmpm.TwoDMap map = (gatech.mmpm.TwoDMap) gs.getMap();
        int sx = map.getSizeInDimension(0);
        int sy = map.getSizeInDimension(1);
        int cellCoor[] = map.toCellCoords(getCoorParam(parameters, "coor"));
        int cx = cellCoor[0];
        int cy = cellCoor[1];
        towers.mmpm.entities.TBase own_base = null, opponent_base = null;

        blocked = new boolean[sx * sy];
        for (int i = 0; i < sx * sy; i++) {
            blocked[i] = false;
        }

        for (gatech.mmpm.Entity e : gs.getAllEntities()) {
            if (e instanceof gatech.mmpm.PhysicalEntity
                && !(e instanceof towers.mmpm.entities.TUnit)) {
                gatech.mmpm.PhysicalEntity pe = (gatech.mmpm.PhysicalEntity) e;

                if (e instanceof towers.mmpm.entities.TBase) {
                    // We only need one of the opponent bases, no matter which one:
                    if (e.getowner().equals(player)) {
                        own_base = (towers.mmpm.entities.TBase) e;
                    } else {
                        opponent_base = (towers.mmpm.entities.TBase) e;
                    }
                }

                cellCoor = map.toCellCoords(pe);
                blocked[cellCoor[0] + cellCoor[1] * sx] = true;
            }
        }

        //		System.out.println("Checking:" +  cx + "," + cy);

        // First test if it is a blocking candidate by checking the surroundings of the coordinate:
        // (this is just a filter, it's not necessary, but makes things faster)
        // This cryptic array contains simply a set of patterns.
        // If a coordinate does NOT satisfy any of the patterns, it is not necessary that we perform the full path finding
        // algorithm, since it is safe to assume that it won't block any path
        boolean patterns[][] = {
            {true, false, true,
                false, false, false,
                false, false, false},
            {false, false, true,
                false, false, false,
                false, false, true},
            {false, false, false,
                false, false, false,
                true, false, true},
            {true, false, false,
                false, false, false,
                true, false, false},
            {false, true, false,
                false, false, false,
                false, true, false},
            {false, false, false,
                true, false, true,
                false, false, false},
            {true, false, false,
                false, false, false,
                false, false, true},
            {false, false, true,
                false, false, false,
                true, false, false},
            {false, true, false,
                false, false, false,
                true, false, false},
            {false, true, false,
                false, false, false,
                false, false, true},
            {true, false, false,
                false, false, true,
                false, false, false},
            {false, false, false,
                false, false, true,
                true, false, false},
            {true, false, false,
                false, false, false,
                false, true, false},
            {false, false, true,
                false, false, false,
                false, true, false},
            {false, false, true,
                true, false, false,
                false, false, false},
            {false, false, false,
                true, false, false,
                false, false, true},};

        for (int i = 0; i < patterns.length; i++) {
            if (patterns[i][0] && !(cx - 1 < 0 || cy - 1 < 0 || cx - 1 >= sx || cy - 1 >= sy || blocked[cx - 1 + (cy - 1) * sx])) {
                continue;
            }
            if (patterns[i][1] && !(cx < 0 || cy - 1 < 0 || cx >= sx || cy - 1 >= sy || blocked[cx + (cy - 1) * sx])) {
                continue;
            }
            if (patterns[i][2] && !(cx + 1 < 0 || cy - 1 < 0 || cx + 1 >= sx || cy - 1 >= sy || blocked[cx + 1 + (cy - 1) * sx])) {
                continue;
            }
            if (patterns[i][3] && !(cx - 1 < 0 || cy < 0 || cx - 1 >= sx || cy >= sy || blocked[cx - 1 + cy * sx])) {
                continue;
            }
            if (patterns[i][4] && !(cx < 0 || cy < 0 || cx >= sx || cy >= sy || blocked[cx + cy * sx])) {
                continue;
            }
            if (patterns[i][5] && !(cx + 1 < 0 || cy < 0 || cx + 1 >= sx || cy >= sy || blocked[cx + 1 + cy * sx])) {
                continue;
            }
            if (patterns[i][6] && !(cx - 1 < 0 || cy + 1 < 0 || cx - 1 >= sx || cy + 1 >= sy || blocked[cx - 1 + (cy + 1) * sx])) {
                continue;
            }
            if (patterns[i][7] && !(cx < 0 || cy + 1 < 0 || cx >= sx || cy + 1 >= sy || blocked[cx + (cy + 1) * sx])) {
                continue;
            }
            if (patterns[i][8] && !(cx + 1 < 0 || cy + 1 < 0 || cx + 1 >= sx || cy + 1 >= sy || blocked[cx + 1 + (cy + 1) * sx])) {
                continue;
            }
            return 1.0f;
        }
        //				System.out.println("Position " + x + "," + y + " satisfies pattern " + i + " -> candidate blocker!");
        {
            // block the coordinate and see if there is a path to any of the opponents (we only need to see if there is
            // a path to one of them, since form any of them there has to be a path to the rest (since all of them are
            // satisfying this restriction):
            blocked[cx + cy * sx] = true;
            int node = (int) (own_base.getx() / 16 + (own_base.gety() / 16) * sx);
            java.util.List<Integer> open = new java.util.LinkedList<Integer>();
            java.util.HashSet<Integer> visited = new java.util.HashSet<Integer>();
            open.add(node);
            visited.add(node);
            while (!open.isEmpty()) {
                node = open.remove(0);
                int x = node % sx;
                int y = node / sx;

                if (!(x - 1 < 0 || y < 0 || x - 1 >= sx || y >= sy || blocked[x - 1 + y * sx])
                    && !visited.contains(node - 1)) {
                    open.add(node - 1);
                    visited.add(node - 1);
                }
                if (!(x + 1 < 0 || y < 0 || x + 1 >= sx || y >= sy || blocked[x + 1 + y * sx])
                    && !visited.contains(node + 1)) {
                    open.add(node - 1);
                    visited.add(node - 1);
                }
                if (!(x < 0 || y - 1 < 0 || x >= sx || y - 1 >= sy || blocked[x + (y - 1) * sx])
                    && !visited.contains(node - sx)) {
                    open.add(node - sx);
                    visited.add(node - sx);
                }
                if (!(x < 0 || y + 1 < 0 || x >= sx || y + 1 >= sy || blocked[x + (y + 1) * sx])
                    && !visited.contains(node + sx)) {
                    open.add(node + sx);
                    visited.add(node + sx);
                }
            }
            node = (int) (opponent_base.getx() / 16 + (opponent_base.gety() / 16) * sx);

            if (visited.contains(node)) {
                return 1.0f;
            }

            return 0.0f;
        }

          ]]>
      </Code>
    </Sensor>
    
    <Sensor name="Gold" type="INTEGER">
      <Code>
        IntAttribute(Entity(Type("towers.mmpm.entities.TPlayer"), player), "gold")
      </Code>
    </Sensor>
    
    <Sensor name="BuildingCost" type="INTEGER">
      <Parameter name="type" type="ENTITY_TYPE"/>
      <Code language="java">
        <![CDATA[
        
		if(parameters == null)
			return 0;
		
        int n = 0;
        
        Class<? extends gatech.mmpm.Entity> type = getTypeParam(parameters, "type");

        if (type == towers.mmpm.entities.TWall.class) 
	    	  return 2;
    		
	      if (type == towers.mmpm.entities.TTower.class) {
		      java.util.List<gatech.mmpm.Entity> l = 
		    	  gs.getEntityByType(towers.mmpm.entities.TTower.class);
		      for(gatech.mmpm.Entity e:l) {
			      if (e.getowner().equals(player)) n++;
		      }
		      return 10*(n+1);
	      }
	      if (type == towers.mmpm.entities.TUpgradeGold.class) {
	    	  java.util.List<gatech.mmpm.Entity> l = 
	    		  gs.getEntityByType(towers.mmpm.entities.TUpgradeGold.class);
		      for(gatech.mmpm.Entity e:l) {
			      if (e.getowner().equals(player)) n++;
		      }
		      return (int)(5*Math.pow(1.5,n));			
	      }
	      if (type == towers.mmpm.entities.TUpgradeUnits.class) {
	    	  java.util.List<gatech.mmpm.Entity> l = 
	    		  gs.getEntityByType(towers.mmpm.entities.TUpgradeUnits.class);
		      for(gatech.mmpm.Entity e:l) {
			      if (e.getowner().equals(player)) n++;
		      }
		      return (int)(5*Math.pow(1.5,n));
	      }
    		
	      return 0;
        ]]>
      </Code>
    </Sensor>
    
  </SensorSet>

  <GoalSet package="towers.mmpm.goals">
    
    <WinGoal name="WinGoal">
      <Code language="java">
        <![CDATA[
		    java.util.List<gatech.mmpm.Entity> l = gs.getAllEntities();
		    float n_enemies_alive = 0.0f;
		    float alive = 0.0f;
    		
		    for(gatech.mmpm.Entity e:l) 
        {
			    if (e instanceof towers.mmpm.entities.TBase) 
          {
				    if (e.getowner().equals(player)) 
					    alive = ((towers.mmpm.entities.TBase)e).getHitpoints();
				    else 
					    n_enemies_alive += ((towers.mmpm.entities.TBase)e).getHitpoints();	
			    }
		    }

		    if (alive==0 && n_enemies_alive==0) 
			    return 0.5f;
		    else 
        {
			    float ret = alive/(alive + n_enemies_alive);
			    return ret;
		    }
        ]]>
        </Code>
    </WinGoal>
    
  </GoalSet>

  <EntitySet package="towers.mmpm.entities">
    
    <Entity>
      <Name>TPlayer</Name>
	    <Super>Entity</Super>
	    <Features>
		    <Feature>
			    <Name>color</Name>
			    <cardinality>single</cardinality>
			    <DataType>String</DataType>
		    </Feature>
		    <Feature>
			    <Name>gold</Name>
			    <cardinality>single</cardinality>
			    <DataType>int</DataType>
		    </Feature>
	    </Features>
	    <Actions>
			    <Action name="Build">
				    <Parameter name="type" value="towers.mmpm.entities.TTower"/>
			    </Action>
			    <Action name="Build">
				    <Parameter name="type" value="towers.mmpm.entities.TWall"/>
			    </Action>
			    <Action name="Build">
				    <Parameter name="type" value="towers.mmpm.entities.TUpgradeGold"/>
			    </Action>
			    <Action name="Build">
				    <Parameter name="type" value="towers.mmpm.entities.TUpgradeUnits"/>
			    </Action>
	    </Actions>		
    </Entity>

    <Entity>
      <Name>TBase</Name>
	    <Super>PhysicalEntity</Super>
	    <Features>
		    <Feature>
			    <Name>hitpoints</Name>
			    <cardinality>single</cardinality>
			    <DataType>int</DataType>
		    </Feature>
		    <Feature>
			    <Name>nextunit</Name>
			    <cardinality>single</cardinality>
			    <DataType>int</DataType>
		    </Feature>
            <Feature>
                <Name>width</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>
            <Feature>
                <Name>length</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>   
	    </Features>
	    <Actions>
	    </Actions>
    </Entity>

    <Entity>
      <Name>TTower</Name>
	    <Super>PhysicalEntity</Super>
	    <Features>
		    <Feature>
			    <Name>nextshot</Name>
			    <cardinality>single</cardinality>
			    <DataType>int</DataType>
		    </Feature>
            <Feature>
                <Name>width</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>
            <Feature>
                <Name>length</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>   
	    </Features>
	    <Actions>
	    </Actions>
    </Entity>


    <Entity>
      <Name>TUnit</Name>
	    <Super>PhysicalEntity</Super>
	    <Features>
		    <Feature>
			    <Name>hitpoints</Name>
			    <cardinality>single</cardinality>
			    <DataType>int</DataType>
		    </Feature>
            <Feature>
                <Name>width</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>
            <Feature>
                <Name>length</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>   
		    <Feature>
			    <Name>target</Name>
			    <cardinality>single</cardinality>
			    <DataType>String</DataType>
		    </Feature>
	    </Features>
	    <Actions>
	    </Actions>
    </Entity>

    <Entity>
      <Name>TUpgradeGold</Name>
	    <Super>PhysicalEntity</Super>
	    <Features>
            <Feature>
                <Name>width</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>
            <Feature>
                <Name>length</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>   
	    </Features>
	    <Actions>
	    </Actions>
    </Entity>

    <Entity>
      <Name>TUpgradeUnits</Name>
	    <Super>PhysicalEntity</Super>
	    <Features>
            <Feature>
                <Name>width</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>
            <Feature>
                <Name>length</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>   
	    </Features>
	    <Actions>
	    </Actions>
    </Entity>

    <Entity>
      <Name>TWall</Name>
	    <Super>PhysicalEntity</Super>
        <ShortName>w</ShortName>
	    <Features>
            <Feature>
                <Name>width</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>
            <Feature>
                <Name>length</Name>
                <DefaultValue>16</DefaultValue>
            </Feature>   
	    </Features>
	    <Actions>
	    </Actions>
    </Entity>

  </EntitySet>    
</Domain>
